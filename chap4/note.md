# 表达式

表达式是由一个或多个运算对象组成的

## 基本概念

函数调用也是一种特殊的运算符，它对运算对象的数量没有限制

在表达式的求值过程中会发生类型转换，具体的转换规则见下文

## 左值和右值

`左值和右值`: 右值对象用的是对象的值，左值对象用的是对象的身份（在内存中的位置）
左值可以当右值用，右值不能当左值用，因此关于运算符的一个重要的属性就是判断其运算对象是否要求左值，以及其运算结果是否为左值

decltype 如果作用于一个结果是左值的表达式会得到一个引用类型，如果是右值则是其类型本身

## 优先级和结合律

优先级决定运算顺序，结合律规定在优先级相同的情况下的组合顺序

例如：

```c
cin >> v1 >> v2; // >> 是左结合，可以方便的把几个IO运算组合在一条表达式中
a = b = 1; // 赋值运算是右结合，因此可以正确赋值
```

## 求值顺序

优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，在大多数情况下不会明确求值顺序

```c
int i = f1() * f2(); // f1和f2的调用顺序不确定
```

对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为

## 算术运算符

算术运算符的运算对象和求值结果都是右值

## 逻辑和关系运算符

运算对象和求值结果都是右值

逻辑运算符规定了求值顺序，先左后右，支持短路运算

`Warring`:进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为比较对象

```c
if (val == true) {} // 只有val==1时为真
```

## 赋值运算符

运算对象必须是一个可修改的左值，返回左值

赋值运算符经常出现在条件中，因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合原意

## 递增和递减运算符

前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回

非必要请使用前置版本

## sizeof

sizeof不会实际求运算对象的值，因此在sizeof运算对象中解引用一个无效指针是安全的

C++11允许使用作用域运算符来获取类成员的大小而无需显示初始化

对string或vector对象执行sizeof只会返回类型固定部分的大小，不会计算对象中的元素占用了多少空间

## 逗号运算符

逗号运算符规定了求值的顺序为从左向右

逗号运算符含有两个运算对象

逗号运算符返回右侧表达式的值，如果右侧表达式是左值，最终的结果也是左值

## 类型转换

### 隐式类型转换

😊

- 在大多数表达式中，比Int类型小的整型值首先提升为较大的整数类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 函数调用时也会发生类型转换，具体看第六章

算术转换：基本的规则是运算符的运算对象转换成最宽的类型，当表达式中既有浮点类型也有整型时，整形转换为浮点

bool char signed char unsigned char short unsigned short 只要其值能存放于int，就转换为int，否则转换为unsigned int

如果一个有符号数和无符号数运算：如果无符号类型不小于带符号类型，那么带符号的转换为无符号的；如果带符号大于无符号，结果依赖于机器：如果无符号类型的所有值都能够存在该带符号类型中，则无符号类型的运算对象转换成带符号类型，如果不能，那么带符号类型的运算对象转换成无符号类型

### 显式类型转换

```c
static_cast: 任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast
const_cast:  只能改变运算对象的底层const
reinterpret_cast: 为运算对象的位模式提供较低层次的重新解释
```
## 算术转换的规则
C++ 中的 **算术转换规则（Usual Arithmetic Conversions）** 是在执行二元算术运算（如 `+`、`-`、`*`、`/`）时，将不同类型的操作数转换为相同类型以确保类型兼容、避免数据丢失的机制。

---

## ✅ 算术转换的目的

使两个操作数具有**相同类型**，便于执行运算。

---

## 🔁 转换步骤（优先级顺序）

### 1. **如果有浮点型参与，优先提升为浮点类型：**

| 如果有...        | 转换为...            |
| ------------- | ----------------- |
| `long double` | 都转为 `long double` |
| `double`      | 都转为 `double`      |
| `float`       | 都转为 `float`       |

---

### 2. **否则，执行整数提升（Integral Promotion）：**

若操作数是：

* `bool`
* `char`
* `signed char`
* `unsigned char`
* `short`
* `unsigned short`

会先转换为 `int` 或 `unsigned int`。

---

### 3. **整数提升后，应用 usual arithmetic conversions：**

如果两个操作数类型不同，C++ 会按照如下规则从左到右依次提升类型（直到两者一致）：

#### **规则摘要：**

* 若类型相同，则直接运算。
* 否则，**较小类型被转换为能表示两者的共同类型**，如：

| 操作数类型                        | 转换为                                                     | 说明 |
| ---------------------------- | ------------------------------------------------------- | -- |
| `int` + `unsigned int`       | 若 `int` 可容纳 `unsigned int`，转为 `int`，否则转为 `unsigned int` |    |
| `int` + `long`               | 转为 `long`                                               |    |
| `int` + `unsigned long`      | 转为 `unsigned long`                                      |    |
| `int` + `long long`          | 转为 `long long`                                          |    |
| `unsigned int` + `long long` | 转为 `long long` 或 `unsigned long long` 视实现               |    |
| `int` + `double`             | 转为 `double`                                             |    |

---

## ✅ 示例

```cpp
short s = 5;
int i = 10;
auto r = s + i;  // s 被提升为 int，结果是 int
```

```cpp
unsigned int u = 3000000000;
int i = -1;
auto r = u + i;  // int 被提升为 unsigned int，r 类型为 unsigned int
```

```cpp
float f = 1.5f;
int i = 2;
auto r = f + i;  // i 转为 float，r 是 float
```

---

## ⚠️ 注意事项

* 整数提升可能造成**符号变化**（如 `int + unsigned int` 的 unsigned 优先）。
* 表达式类型的最终结果可能会影响函数调用、模板推导、重载决议等。

---

## 🧠 总结图表

| 类型优先级（高 → 低）         |
| -------------------- |
| `long double`        |
| `double`             |
| `float`              |
| `unsigned long long` |
| `long long`          |
| `unsigned long`      |
| `long`               |
| `unsigned int`       |
| `int`（或整数提升结果）       |

---

如你有具体的两个不同类型相加的例子，我可以直接推导它们会被转换为什么类型。
