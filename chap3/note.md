# chap3 字符串、向量和数组

string 和 vector 是两种最重要的标准库类型

## string

`Note`:C++标准一方面对库类型所提供的操作做了详细规定，另一方面对库的实现者做出了一些性能上的需求，因此，标准库类型对于一般应用场合来说有足够的效率

### 定义与初始化

```c++
string s1; // 默认初始化，s1是一个空串
string s1(s1); // s2是s1的副本
string s2 = s1; // 拷贝初始化
string s3("value"); // s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"；// 拷贝初始化
string s4(n, 'c'); // 把s4初始化为由连续的n个字符c组成的串
```

#### 直接初始化与拷贝初始化

如果使用`=`，执行的是拷贝初始化，否则是直接初始化
直接初始化通常更高效（避免隐式转换和临时对象）。
拷贝初始化在涉及隐式转换时可能多一步拷贝/移动操作（但编译器可能优化）。

### string对象上的操作

#### 读取未知数量的string对象

```c
string word;
while(cin >> word) {
    cout << word << endl;
}
```

#### 使用getline读取一整行

getline从输入流中读取内容，知道遇到换行符，注意换行符会被读取但是不会写入到输出变量中
如果输入一开始就是换行符，返回空string

```c
string line;
while(getline(cin, line)) {
    cout << line << endl;
}
```

#### cin和getline对空表字符的处理

cin >> :
跳过前导空白字符：自动忽略输入流开头的所有空格、制表符、换行符等。
遇到空白字符停止：读取非空白字符后，一旦遇到任意空白字符，立即停止读取。
不存储空白字符：终止时的空白字符仍留在输入流中，不会被提取到字符串。

getline:
不跳过任何空白字符：会读取所有字符（包括前导空格、制表符）。
遇到换行符 \n 停止：读取到换行符为止，但换行符本身不存储到字符串中。
移除换行符：换行符从输入流中被提取并丢弃，不会留在流中。
保留其他空白：字符串中可能包含空格、制表符等非换行空白字符。

#### string::size_type类型

string.size()返回的是一个size_type类型的值，是一个无符号整数，因此：
`Note`:如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题

#### 比较

如果两个string对象再某些对应位置上不相等，则比较的结果是string对象中第一对相异字符比较的结果

#### 字面值和string相加

标准库允许把字符字面值和字符串字面值转换成string对象
必须确保每个加法运算符的两侧运算对象至少有一个是string

### 混用string和C风格字符串

```c
// 我们无法保证c_str()返回的数组一直有效，如果后序的操作改变了s，可能会使之间返回的数组失效
const char *str = s.c_str();
```

`Note`:如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该函数重新拷贝一份

## vector

### 定义与初始化

```c
vector<T> v1; // 默认初始化
vector<T> v2(v1); // 直接初始化
vector<T> v2 = v1; // 拷贝初始化
vector<T> v5{a,b,c,d}; // 列表初始化
```

区分大括号和圆括号

```c
vector<int> v1(10); // 10个元素
vector<int> v2{10}; // 1个元素
vector<string> v3{10}; // 10个元素
```

### 遍历

`Note`: 范围for循环不应该改变其遍历序列的大小，如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环

## 迭代器

迭代器分为有效和无效
有效的迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他情况都属于无效

如果容器元素为空，begin()和end()都返回尾后迭代器

`最佳实践`:最好在for循环中使用!=来判断循环边界而不是使用传统的<=,因为所有的标准库的迭代器都定义了==和!=，但是它们当中的绝大多数都没有定义<运算符

### cbegin和cend

C++11新引入，不论容器对象本身是否是常量，返回值都是const_iterator

### 使用数组初始化vector

```c
int arr[] = {1,2,3,4,5};
vector<int> ivec(begin(arr), end(arr)); // 指明拷贝区域的首元素地址和尾元素地址,左闭右开
```

## 数组

数组的维度必须是常量表达式

引用不是对象，不存在引用的数组
但是可以定义数组的引用

默认情况下，数组的元素别默认初始化，`和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值`

定义数组的时候必须指定数组的类型，`不允许`使用auto根据初始值自动推导

允许列表初始化，此时允许忽略数组的维度自动根据列表初始值的数量推导，如果维度比初始值列表提供的数量大，则用初始值列表提供的元素初始化靠前的元素，后面的元素执行默认初始化

### 字符数组的特殊性

注意尾零
用字符串字面值初始化没有指定维度的字符数组，字符数组的维度为字符串长度加一

### 复杂数组的声明

```c
int *ptr[10];
int arr[10];
int (*ptr)[10] = &arr; // 指向一个含有10个整数的数组
int (&ref)[10] = arr; // ref引用一个含有10个整数的数组
```

基本的阅读规则：从内向外阅读

### 指针和数组

使用数组的时候，编译器一般会把它转换成指针

当一个数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组

当使用decltype关键字时，上述转换不会发生，decltype返回的是10个整数构成的数组

### 增强安全的begin()和end()

C++11标准引入了两个函数begin()和end()，用来快速得到首指针和尾后指针

### 多维数组

`Note`：要使用范围for循环处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该时引用类型，为了避免数组被自动转换成指针
